// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

// An interface that all entities with an ID implement.
type Node interface {
	IsNode()
	// The unique identifier for the entity.
	GetID() string
}

// A single author of books.
type Author struct {
	// The unique identifier for the author.
	ID string `json:"id"`
	// The name of the author.
	Name string `json:"name"`
	// A biography or description of the author's life and work.
	Biography *string `json:"biography,omitempty"`
	// A list of books written by the author.
	Books []*Book `json:"books"`
}

func (Author) IsNode() {}

// The unique identifier for the entity.
func (this Author) GetID() string { return this.ID }

// Represents a book in the store.
type Book struct {
	// The unique identifier for the book.
	ID string `json:"id"`
	// The title of the book.
	Title string `json:"title"`
	// A brief description of the book's content.
	Description *string `json:"description,omitempty"`
	// The year the book was published.
	PublishedYear *int `json:"publishedYear,omitempty"`
	// The genre of the book.
	Genre Genre `json:"genre"`
	// The price of the book.
	Price float64 `json:"price"`
	// The status of the book (e.g., available, out of stock).
	Status BookStatus `json:"status"`
	// The author who wrote the book.
	Author *Author `json:"author"`
}

func (Book) IsNode() {}

// The unique identifier for the entity.
func (this Book) GetID() string { return this.ID }

// A paginated list of books.
type BookConnection struct {
	// The total number of books matching the query.
	TotalCount int `json:"totalCount"`
	// A list of book edges, each containing a book and its cursor.
	Edges []*BookEdge `json:"edges"`
	// Metadata about the current page of results.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An edge that contains a book and its cursor.
type BookEdge struct {
	// A unique cursor for the book in the current connection.
	Cursor string `json:"cursor"`
	// The actual book entity represented by this edge.
	Node *Book `json:"node"`
}

// Input for filtering books in a query.
type BookFilterInput struct {
	// Filter by the book's genre.
	Genre *Genre `json:"genre,omitempty"`
	// Filter by the book's status (e.g., available, out of stock).
	Status *BookStatus `json:"status,omitempty"`
	// Filter by the ID of the author of the book.
	AuthorID *string `json:"authorId,omitempty"`
	// Filter by the minimum price of the book.
	MinPrice *float64 `json:"minPrice,omitempty"`
	// Filter by the maximum price of the book.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
	// Filter by books published after a specific year.
	PublishedAfter *int `json:"publishedAfter,omitempty"`
	// Filter by books published before a specific year.
	PublishedBefore *int `json:"publishedBefore,omitempty"`
	// Search text that matches the book's title or description.
	SearchText *string `json:"searchText,omitempty"`
}

// Input for listing books with pagination, sorting, and filtering.
type BookListInput struct {
	// Filters to apply when listing books.
	Filter *BookFilterInput `json:"filter,omitempty"`
	// The maximum number of books to return in the list.
	// Defaults to 10.
	First *int `json:"first,omitempty"`
	// The cursor to start retrieving books after.
	After *string `json:"after,omitempty"`
	// The field to sort the list of books by.
	// Defaults to TITLE.
	SortBy *BookSortField `json:"sortBy,omitempty"`
}

// Input for creating a new book.
type CreateBookInput struct {
	// The title of the book.
	Title string `json:"title"`
	// A brief description of the book's content.
	Description *string `json:"description,omitempty"`
	// The year the book was published.
	PublishedYear *int `json:"publishedYear,omitempty"`
	// The genre of the book.
	Genre Genre `json:"genre"`
	// The price of the book.
	Price float64 `json:"price"`
	// The status of the book (e.g., available, out of stock).
	Status BookStatus `json:"status"`
	// The ID of the author who wrote the book.
	AuthorID string `json:"authorId"`
}

// Root mutation type for modifying data in the API.
type Mutation struct{}

// Pagination metadata for a connection.
// Follows the Relay Cursor Connections Specification.
type PageInfo struct {
	// Indicates whether there is a next page of data.
	HasNextPage bool `json:"hasNextPage"`
	// Indicates whether there is a previous page of data.
	HasPreviousPage bool `json:"hasPreviousPage"`
	// The cursor corresponding to the start of the current page.
	StartCursor *string `json:"startCursor,omitempty"`
	// The cursor corresponding to the end of the current page.
	EndCursor *string `json:"endCursor,omitempty"`
}

// Root query type for retrieving data from the API.
type Query struct{}

// Input for updating an existing book.
type UpdateBookInput struct {
	// Update the title of the book.
	Title *string `json:"title,omitempty"`
	// Update the description of the book's content.
	Description *string `json:"description,omitempty"`
	// Update the year the book was published.
	PublishedYear *int `json:"publishedYear,omitempty"`
	// Update the genre of the book.
	Genre *Genre `json:"genre,omitempty"`
	// Update the price of the book.
	Price *float64 `json:"price,omitempty"`
	// Update the status of the book (e.g., available, out of stock).
	Status *BookStatus `json:"status,omitempty"`
	// Update the ID of the author who wrote the book.
	AuthorID *string `json:"authorId,omitempty"`
}

// Fields that can be used to sort a list of books.
type BookSortField string

const (
	// Sort by the book's title.
	BookSortFieldTitle BookSortField = "TITLE"
	// Sort by the year the book was published.
	BookSortFieldPublishedYear BookSortField = "PUBLISHED_YEAR"
	// Sort by the price of the book.
	BookSortFieldPrice BookSortField = "PRICE"
)

var AllBookSortField = []BookSortField{
	BookSortFieldTitle,
	BookSortFieldPublishedYear,
	BookSortFieldPrice,
}

func (e BookSortField) IsValid() bool {
	switch e {
	case BookSortFieldTitle, BookSortFieldPublishedYear, BookSortFieldPrice:
		return true
	}
	return false
}

func (e BookSortField) String() string {
	return string(e)
}

func (e *BookSortField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BookSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BookSortField", str)
	}
	return nil
}

func (e BookSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BookSortField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BookSortField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents the status of a book in the store.
type BookStatus string

const (
	// The book is available for purchase.
	BookStatusAvailable BookStatus = "AVAILABLE"
	// The book is currently out of stock.
	BookStatusOutOfStock BookStatus = "OUT_OF_STOCK"
	// The book is no longer being sold.
	BookStatusDiscontinued BookStatus = "DISCONTINUED"
)

var AllBookStatus = []BookStatus{
	BookStatusAvailable,
	BookStatusOutOfStock,
	BookStatusDiscontinued,
}

func (e BookStatus) IsValid() bool {
	switch e {
	case BookStatusAvailable, BookStatusOutOfStock, BookStatusDiscontinued:
		return true
	}
	return false
}

func (e BookStatus) String() string {
	return string(e)
}

func (e *BookStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BookStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BookStatus", str)
	}
	return nil
}

func (e BookStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BookStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BookStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents the genre of a book.
type Genre string

const (
	// A work of fiction or imaginative narrative.
	GenreFiction Genre = "FICTION"
	// A work based on real facts or events.
	GenreNonFiction Genre = "NON_FICTION"
	// A work related to scientific subjects.
	GenreScience Genre = "SCIENCE"
	// A historical work or book about past events.
	GenreHistory Genre = "HISTORY"
	// A work of fantasy including magical or supernatural elements.
	GenreFantasy Genre = "FANTASY"
	// A written account of someone's life experiences.
	GenreBiography Genre = "BIOGRAPHY"
	// A book intended for children or younger audiences.
	GenreChildren Genre = "CHILDREN"
	// A work primarily focused on romantic relationships.
	GenreRomance Genre = "ROMANCE"
	// A story with elements of suspense or excitement, usually including danger.
	GenreThriller Genre = "THRILLER"
	// A story that involves solving a crime or uncovering secrets.
	GenreMystery Genre = "MYSTERY"
	// A book intended to provide guidelines or advice on self-improvement.
	GenreSelfHelp Genre = "SELF_HELP"
)

var AllGenre = []Genre{
	GenreFiction,
	GenreNonFiction,
	GenreScience,
	GenreHistory,
	GenreFantasy,
	GenreBiography,
	GenreChildren,
	GenreRomance,
	GenreThriller,
	GenreMystery,
	GenreSelfHelp,
}

func (e Genre) IsValid() bool {
	switch e {
	case GenreFiction, GenreNonFiction, GenreScience, GenreHistory, GenreFantasy, GenreBiography, GenreChildren, GenreRomance, GenreThriller, GenreMystery, GenreSelfHelp:
		return true
	}
	return false
}

func (e Genre) String() string {
	return string(e)
}

func (e *Genre) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Genre(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Genre", str)
	}
	return nil
}

func (e Genre) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Genre) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Genre) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
