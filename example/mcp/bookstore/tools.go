// Code generated by github.com/wimspaargaren/gql-gen-mcp, DO NOT EDIT.
package main

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"

	"github.com/wimspaargaren/gql-gen-mcp/graphql"
)

// ToolRegistry is a struct that holds the MCPServer, GraphQLClient and all tools.
type ToolRegistry struct {
	MCPServer     *server.MCPServer
	GraphQLClient *graphql.Client
}

// NewToolRegistry creates a new ToolRegistry with the given MCPServer and GraphQLClient.
func NewToolRegistry(mcpServer *server.MCPServer, gqlClient *graphql.Client) *ToolRegistry {
	return &ToolRegistry{
		MCPServer:     mcpServer,
		GraphQLClient: gqlClient,
	}
}

// RegisterTools registers all tools in the ToolRegistry with the MCPServer.
func (t *ToolRegistry) RegisterTools() {
	// Register each tool with the MCPServer
	t.RegisterBooksTool()
	t.RegisterBookTool()
	t.RegisterAuthorTool()
	t.RegisterAuthorsTool()
	t.RegisterCreateBookTool()
	t.RegisterUpdateBookTool()
	t.RegisterDeleteBookTool()
}

// RegisterBooksTool Retrieve a paginated list of books with optional filters and sorting.
func (t *ToolRegistry) RegisterBooksTool() {
	booksTool := mcp.NewTool("books",
		mcp.WithDescription("Retrieve a paginated list of books with optional filters and sorting."),

		mcp.WithObject("input",
			mcp.Description(""),
			mcp.Properties(map[string]any{"filter": map[string]any{"type": "object", "description": "Filters to apply when listing books.", "properties": map[string]any{"genre": map[string]any{"type": "string", "description": "Filter by the book's genre.", "enum": []string{"FICTION", "NON_FICTION", "SCIENCE", "HISTORY", "FANTASY", "BIOGRAPHY", "CHILDREN", "ROMANCE", "THRILLER", "MYSTERY", "SELF_HELP"}}, "status": map[string]any{"type": "string", "description": "Filter by the book's status (e.g., available, out of stock).", "enum": []string{"AVAILABLE", "OUT_OF_STOCK", "DISCONTINUED"}}, "authorId": map[string]any{"type": "string", "description": "Filter by the ID of the author of the book."}, "minPrice": map[string]any{"type": "number", "description": "Filter by the minimum price of the book."}, "maxPrice": map[string]any{"type": "number", "description": "Filter by the maximum price of the book."}, "publishedAfter": map[string]any{"type": "number", "description": "Filter by books published after a specific year."}, "publishedBefore": map[string]any{"type": "number", "description": "Filter by books published before a specific year."}, "searchText": map[string]any{"type": "string", "description": "Search text that matches the book's title or description."}}}, "first": map[string]any{"type": "number", "description": "The maximum number of books to return in the list. Defaults to 10."}, "after": map[string]any{"type": "string", "description": "The cursor to start retrieving books after."}, "sortBy": map[string]any{"type": "string", "description": "The field to sort the list of books by. Defaults to TITLE.", "enum": []string{"TITLE", "PUBLISHED_YEAR", "PRICE"}}}),
		),
	)
	t.MCPServer.AddTool(booksTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		query books ($input: BookListInput) {
			books(input: $input) {
				totalCount 
				edges {
					cursor 
					node {
						id 
						title 
						description 
						publishedYear 
						genre 
						price 
						status 
						author {
							id 
							name 
							biography 
						}
					}
				}
				pageInfo {
					hasNextPage 
					hasPreviousPage 
					startCursor 
					endCursor 
				}
			}

		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "books",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}

// RegisterBookTool Retrieve a single book by its unique ID.
func (t *ToolRegistry) RegisterBookTool() {
	bookTool := mcp.NewTool("book",
		mcp.WithDescription("Retrieve a single book by its unique ID."),

		mcp.WithString("id",
			mcp.Description(""),
			mcp.Required(),
		),
	)
	t.MCPServer.AddTool(bookTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		query book ($id: ID!) {
			book(id: $id) {
				id 
				title 
				description 
				publishedYear 
				genre 
				price 
				status 
				author {
					id 
					name 
					biography 
				}
			}

		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "book",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}

// RegisterAuthorTool Retrieve a single author by their unique ID.
func (t *ToolRegistry) RegisterAuthorTool() {
	authorTool := mcp.NewTool("author",
		mcp.WithDescription("Retrieve a single author by their unique ID."),

		mcp.WithString("id",
			mcp.Description(""),
			mcp.Required(),
		),
	)
	t.MCPServer.AddTool(authorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		query author ($id: ID!) {
			author(id: $id) {
				id 
				name 
				biography 
				books {
					id 
					title 
					description 
					publishedYear 
					genre 
					price 
					status 
				}
			}

		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "author",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}

// RegisterAuthorsTool Retrieve a list of all authors.
func (t *ToolRegistry) RegisterAuthorsTool() {
	authorsTool := mcp.NewTool("authors",
		mcp.WithDescription("Retrieve a list of all authors."),
	)
	t.MCPServer.AddTool(authorsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		query authors  {
			authors {
				id 
				name 
				biography 
				books {
					id 
					title 
					description 
					publishedYear 
					genre 
					price 
					status 
				}
			}

		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "authors",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}

// RegisterCreateBookTool Create a new book entry in the store.
func (t *ToolRegistry) RegisterCreateBookTool() {
	createBookTool := mcp.NewTool("createBook",
		mcp.WithDescription("Create a new book entry in the store."),

		mcp.WithObject("input",
			mcp.Description(""),
			mcp.Required(),
			mcp.Properties(map[string]any{"title": map[string]any{"type": "string", "description": "The title of the book."}, "description": map[string]any{"type": "string", "description": "A brief description of the book's content."}, "publishedYear": map[string]any{"type": "number", "description": "The year the book was published."}, "genre": map[string]any{"type": "string", "description": "The genre of the book.", "enum": []string{"FICTION", "NON_FICTION", "SCIENCE", "HISTORY", "FANTASY", "BIOGRAPHY", "CHILDREN", "ROMANCE", "THRILLER", "MYSTERY", "SELF_HELP"}}, "price": map[string]any{"type": "number", "description": "The price of the book."}, "status": map[string]any{"type": "string", "description": "The status of the book (e.g., available, out of stock).", "enum": []string{"AVAILABLE", "OUT_OF_STOCK", "DISCONTINUED"}}, "authorId": map[string]any{"type": "string", "description": "The ID of the author who wrote the book."}}),
		),
	)
	t.MCPServer.AddTool(createBookTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		mutation createBook ($input: CreateBookInput!) {
			createBook(input: $input) {
				id 
				title 
				description 
				publishedYear 
				genre 
				price 
				status 
				author {
					id 
					name 
					biography 
				}
			}

		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "createBook",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}

// RegisterUpdateBookTool Update an existing book.
func (t *ToolRegistry) RegisterUpdateBookTool() {
	updateBookTool := mcp.NewTool("updateBook",
		mcp.WithDescription("Update an existing book."),

		mcp.WithString("id",
			mcp.Description(""),
			mcp.Required(),
		),
		mcp.WithObject("input",
			mcp.Description(""),
			mcp.Required(),
			mcp.Properties(map[string]any{"title": map[string]any{"type": "string", "description": "Update the title of the book."}, "description": map[string]any{"type": "string", "description": "Update the description of the book's content."}, "publishedYear": map[string]any{"type": "number", "description": "Update the year the book was published."}, "genre": map[string]any{"type": "string", "description": "Update the genre of the book.", "enum": []string{"FICTION", "NON_FICTION", "SCIENCE", "HISTORY", "FANTASY", "BIOGRAPHY", "CHILDREN", "ROMANCE", "THRILLER", "MYSTERY", "SELF_HELP"}}, "price": map[string]any{"type": "number", "description": "Update the price of the book."}, "status": map[string]any{"type": "string", "description": "Update the status of the book (e.g., available, out of stock).", "enum": []string{"AVAILABLE", "OUT_OF_STOCK", "DISCONTINUED"}}, "authorId": map[string]any{"type": "string", "description": "Update the ID of the author who wrote the book."}}),
		),
	)
	t.MCPServer.AddTool(updateBookTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		mutation updateBook ($id: ID!, $input: UpdateBookInput!) {
			updateBook(id: $id, input: $input) {
				id 
				title 
				description 
				publishedYear 
				genre 
				price 
				status 
				author {
					id 
					name 
					biography 
				}
			}

		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "updateBook",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}

// RegisterDeleteBookTool Delete a book by its unique ID.
func (t *ToolRegistry) RegisterDeleteBookTool() {
	deleteBookTool := mcp.NewTool("deleteBook",
		mcp.WithDescription("Delete a book by its unique ID."),

		mcp.WithString("id",
			mcp.Description(""),
			mcp.Required(),
		),
	)
	t.MCPServer.AddTool(deleteBookTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var res map[string]any
		query := `
		mutation deleteBook ($id: ID!) {
			deleteBook(id: $id) 
		}
	`
		err := t.GraphQLClient.Call(ctx, graphql.Request{
			Query:         query,
			Variables:     request.Params.Arguments,
			OperationName: "deleteBook",
		}, &res)
		if err != nil {
			return nil, fmt.Errorf("failed to call GraphQL API: %w", err)
		}
		b, err := json.Marshal(res)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal response: %w", err)
		}
		return mcp.NewToolResultText(string(b)), nil
	})
}
