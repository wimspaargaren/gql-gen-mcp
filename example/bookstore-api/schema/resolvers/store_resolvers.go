package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"

	models1 "github.com/wimspaargaren/gql-gen-mcp/example/bookstore-api/schema/models"
	"github.com/wimspaargaren/gql-gen-mcp/example/bookstore-api/schema/repository"
	server1 "github.com/wimspaargaren/gql-gen-mcp/example/bookstore-api/schema/server"
)

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input models1.CreateBookInput) (*models1.Book, error) {
	createBookInput := repository.CreateBookInput{
		Title:    input.Title,
		Genre:    repository.Genre(input.Genre),
		Price:    input.Price,
		AuthorID: input.AuthorID,
		Status:   repository.BookStatus(input.Status),
	}

	if input.Description != nil {
		createBookInput.Description = *input.Description
	}

	if input.PublishedYear != nil {
		createBookInput.PublishedYear = *input.PublishedYear
	}

	author, err := r.authorRepository.GetAuthor(ctx, input.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("invalid author provided: %w", err)
	}

	book, err := r.bookRepository.CreateBook(ctx, &createBookInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create book: %w", err)
	}

	return &models1.Book{
		ID:            book.ID,
		Title:         book.Title,
		Description:   &book.Description,
		PublishedYear: &book.PublishedYear,
		Genre:         models1.Genre(book.Genre),
		Price:         book.Price,
		Status:        models1.BookStatus(book.Status),
		Author: &models1.Author{
			ID:        author.ID,
			Name:      author.Name,
			Biography: &author.BioGraphy,
		},
	}, nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, input models1.UpdateBookInput) (*models1.Book, error) {
	updateBookInput := repository.UpdateBookInput{
		Title:         input.Title,
		Description:   input.Description,
		PublishedYear: input.PublishedYear,
		Price:         input.Price,
		AuthorID:      input.AuthorID,
	}
	if input.Genre != nil {
		repositoryGenre := repository.Genre(*input.Genre)
		updateBookInput.Genre = &repositoryGenre
	}
	if input.Status != nil {
		repositoryStatus := repository.BookStatus(*input.Status)
		updateBookInput.Status = &repositoryStatus
	}

	if updateBookInput.AuthorID != nil {
		_, err := r.authorRepository.GetAuthor(ctx, *updateBookInput.AuthorID)
		if err != nil {
			return nil, fmt.Errorf("invalid author provided: %w", err)
		}
	}

	book, err := r.bookRepository.UpdateBook(ctx, id, updateBookInput)
	if err != nil {
		return nil, fmt.Errorf("failed to update book: %w", err)
	}
	author, err := r.authorRepository.GetAuthor(ctx, book.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("invalid author provided: %w", err)
	}

	return bookAndAuthorToModel(book, author), nil
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	deleted, err := r.bookRepository.DeleteBook(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete book: %w", err)
	}
	return deleted, nil
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context, input *models1.BookListInput) (*models1.BookConnection, error) {
	filter := &repository.BookFilterInput{}
	if input != nil {
		if input.Filter != nil {
			filter.AuthorID = input.Filter.AuthorID
			filter.MinPrice = input.Filter.MinPrice
			filter.MaxPrice = input.Filter.MaxPrice
			filter.PublishedAfter = input.Filter.PublishedAfter
			filter.PublishedBefore = input.Filter.PublishedBefore
			filter.SearchText = input.Filter.SearchText
			if filter.Genre != nil {
				repositoryGenre := repository.Genre(*input.Filter.Genre)
				filter.Genre = &repositoryGenre
			}
			if input.Filter.Status != nil {
				repositoryStatus := repository.BookStatus(*input.Filter.Status)
				filter.Status = &repositoryStatus
			}
		}
	}

	sortBy := "id"
	if input != nil && input.SortBy != nil {
		sortBy = input.SortBy.String()
	}

	bookListInput := repository.BookListInput{
		Filter: filter,
		SortBy: &sortBy,
	}
	if input != nil {
		bookListInput.First = input.First
		bookListInput.After = input.After
	}

	books, totalCount, err := r.bookRepository.GetBooks(ctx, bookListInput)
	if err != nil {
		return nil, fmt.Errorf("failed to get books: %w", err)
	}
	edges := []*models1.BookEdge{}
	for _, book := range books {
		author, err := r.authorRepository.GetAuthor(ctx, book.AuthorID)
		if err != nil {
			return nil, fmt.Errorf("failed to get author: %w", err)
		}
		edges = append(edges, &models1.BookEdge{
			Cursor: book.ID,
			Node:   bookAndAuthorToModel(book, author),
		})
	}
	return &models1.BookConnection{
		Edges:      edges,
		PageInfo:   &models1.PageInfo{},
		TotalCount: totalCount,
	}, nil
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id string) (*models1.Book, error) {
	book, err := r.bookRepository.GetBook(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get book: %w", err)
	}
	author, err := r.authorRepository.GetAuthor(ctx, book.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("failed to get author: %w", err)
	}
	return bookAndAuthorToModel(book, author), nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*models1.Author, error) {
	author, err := r.authorRepository.GetAuthor(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get author: %w", err)
	}
	books, err := r.resultingBooksForAuthor(ctx, author.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get books for author: %w", err)
	}

	return &models1.Author{
		ID:        "1",
		Name:      "John Doe",
		Biography: &author.BioGraphy,
		Books:     books,
	}, nil
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context) ([]*models1.Author, error) {
	authors, err := r.authorRepository.GetAuthors(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get authors: %w", err)
	}
	result := []*models1.Author{}
	for _, author := range authors {
		books, err := r.resultingBooksForAuthor(ctx, author.ID)
		if err != nil {
			return nil, fmt.Errorf("failed to get books for author: %w", err)
		}
		result = append(result, &models1.Author{
			ID:        author.ID,
			Name:      author.Name,
			Biography: &author.BioGraphy,
			Books:     books,
		})
	}

	return result, nil
}

// Mutation returns server1.MutationResolver implementation.
func (r *Resolver) Mutation() server1.MutationResolver { return &mutationResolver{r} }

// Query returns server1.QueryResolver implementation.
func (r *Resolver) Query() server1.QueryResolver { return &queryResolver{r} }

type (
	mutationResolver struct{ *Resolver }
	queryResolver    struct{ *Resolver }
)
